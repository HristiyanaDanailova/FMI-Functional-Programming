(#%require racket/port)
; отваря се порт , който чете от дадения файл
(define in (open-input-file "input.txt"))

; функция, която разделя стринг на лист от стрингове според подаден delimiter
;https://cookbook.scheme.org/split-string/
(define (string-split char-delimiter? string)
  (define (maybe-add a b parts)
    (if (= a b) parts (cons (substring string a b) parts)))
  (let ((n (string-length string)))
    (let loop ((a 0) (b 0) (parts '()))
      (if (< b n)
          (if (not (char-delimiter? (string-ref string b)))
              (loop a (+ b 1) parts)
              (loop (+ b 1) (+ b 1) (maybe-add a b parts)))
          (reverse (maybe-add a b parts))))))

;групира елементите на списък 2 по 2
(define (group l)
  (define (helper curr res ls)
    (if (= curr (length l))
        res
        (helper (+ curr 2) (append res (list (list (car ls) (car (cdr ls))))) (cdr (cdr ls)))))
  (helper 0 '() l))

; проверява дали даден стринг е число
(define (str-dig? str)
  (or (string=? "0" str)
      (string=? "1" str)
      (string=? "2" str)
      (string=? "3" str)
      (string=? "4" str)
      (string=? "5" str)
      (string=? "6" str)
      (string=? "7" str)
      (string=? "8" str)
      (string=? "9" str)
      (string=? "10" str)
      ))
;сравнява всяка двойка елементи елемент по елемент, според правилата по условие
(define (funcStr? l1 l2)
  (cond ((and (str-dig? (car l1))
              (str-dig? (car l2))) (if (< (string->number (car l1)) (string->number (car l2)))
                                         #t
                                         (if (> (string->number (car l1)) (string->number (car l2)))
                                             #f
                                             (funcStr? (cdr l1) (cdr l2)))))
        ((and (string=? "[" (car l1))
              (string=? "[" (car l2))) (funcStr? (cdr l1) (cdr l2)))

        ((and (string=? "[" (car l1))
              (string=? "]" (car l2))) #f)

        ((and (string=? "]" (car l1))
              (string=? "[" (car l2))) #t)

        ((and (string=? "]" (car l1))
              (str-dig? (car l2))) #t)
        
        ((and (string=? "]" (car l1))
              (string=? "]" (car l2)))  (funcStr? (cdr l1) (cdr l2)))

        ((and (str-dig? (car l1))
              (string=? "]" (car l2))) #f)
        
        ((and (str-dig? (car l1))
              (string=? "[" (car l2)))  (funcStr? (append (list "[" (car l1) "]") (cdr l1)) l2))
        
        ((and (string=? "[" (car l1))
              (str-dig? (car l2)))   (funcStr? l1 (append (list "[" (car l2)  "]") (cdr l2))))
        ))

;сумира индексите на всички елементи, които са в правилен ред
(define (iter l)
  (define (helper curr sum)
    (if (= curr (length l))
        sum
        (helper (+ curr 1) (if (eq? #t (list-ref l curr))
                               (+ sum (+ 1 curr))
                               sum))))
  (helper 0 0))

;форматика списък като преобразува елементите към стрингове
(define (format l)
  (if (null? l)
      '()
      (cons (if (char=? (car l) #\1)
                (if (char=? (car (cdr l)) #\0)
                  "10"
                  (string (car l)))
                (if (not (char=? #\, (car l)))
                    (string (car l))
                    ""
                    )) (format (cdr l)))))

;за даден списък прескача елементите от тип ""
(define (skip-empty l)
  (if (null? l)
      '()
      (if (string=? "" (car l))
          (skip-empty (cdr l))
          (cons (car l) (skip-empty (cdr l))))))

;към всеки ред от кода е показан пример и резултат от изпълнението
(define input (port->string in))
;-> "[[[[8,7,8,5,4],6,[4,6]]],[6,[[]]],[]]\r\n[[[[8,0,0,7,1],[1],8]]]"
(define splitInp (string-split char-whitespace? input))
;-> ("[[[[8,7,8,5,4],6,[4,6]]],[6,[[]]],[]]" "[[[[8,0,0,7,1],[1],8]]]")
(define prs (map (lambda(x) (list (skip-empty (format (string->list (car x)))) (skip-empty(format (string->list (car (cdr x))))))) (group splitInp)))
;-> ((("[" "[" "[" "[" "8" "7" "8" "5" "4" "]" "6" "[" "4" "6" "]" "]" "]" "[" "6" "[" "[" "]" "]" "]" "[" "]" "]")
;   ("[" "[" "[" "[" "8" "0" "0" "7" "1" "]" "[" "1" "]" "8" "]" "]" "]"))
(iter (map  (lambda(x) (funcStr? (car x) (car (cdr x)))) prs))
;резултат