(#%require racket/port)
; отваря се порт , който чете от дадения файл
(define in (open-input-file "input.txt"))

; функция, която разделя стринг на лист от стрингове според подаден delimiter
;https://cookbook.scheme.org/split-string/
(define (string-split char-delimiter? string)
  (define (maybe-add a b parts)
    (if (= a b) parts (cons (substring string a b) parts)))
  (let ((n (string-length string)))
    (let loop ((a 0) (b 0) (parts '()))
      (if (< b n)
          (if (not (char-delimiter? (string-ref string b)))
              (loop a (+ b 1) parts)
              (loop (+ b 1) (+ b 1) (maybe-add a b parts)))
          (reverse (maybe-add a b parts))))))

(define (foldr op nv l)
  (if (null? l) nv
      (op (car l) (foldr op nv (cdr l)))))

; проверява дали даден стринг е число
(define (str-dig? str)
  (or (string=? "0" str)
      (string=? "1" str)
      (string=? "2" str)
      (string=? "3" str)
      (string=? "4" str)
      (string=? "5" str)
      (string=? "6" str)
      (string=? "7" str)
      (string=? "8" str)
      (string=? "9" str)
      (string=? "10" str)
      ))
;сравнява всяка двойка елементи елемент по елемент, според правилата по условие
(define (funcStr? l1 l2)
  (cond ((and (str-dig? (car l1))
              (str-dig? (car l2))) (if (< (string->number (car l1)) (string->number (car l2)))
                                         #t
                                         (if (> (string->number (car l1)) (string->number (car l2)))
                                             #f
                                             (funcStr? (cdr l1) (cdr l2)))))
        ((and (string=? "[" (car l1))
              (string=? "[" (car l2))) (funcStr? (cdr l1) (cdr l2)))

        ((and (string=? "[" (car l1))
              (string=? "]" (car l2))) #f)

        ((and (string=? "]" (car l1))
              (string=? "[" (car l2))) #t)

        ((and (string=? "]" (car l1))
              (str-dig? (car l2))) #t)
        
        ((and (string=? "]" (car l1))
              (string=? "]" (car l2)))  (funcStr? (cdr l1) (cdr l2)))

        ((and (str-dig? (car l1))
              (string=? "]" (car l2))) #f)
        
        ((and (str-dig? (car l1))
              (string=? "[" (car l2)))  (funcStr? (append (list "[" (car l1) "]") (cdr l1)) l2))
        
        ((and (string=? "[" (car l1))
              (str-dig? (car l2)))   (funcStr? l1 (append (list "[" (car l2)  "]") (cdr l2))))
        ))


;форматика списък като преобразува елементите към стрингове
(define (format l)
  (if (null? l)
      '()
      (cons (if (char=? (car l) #\1)
                (if (char=? (car (cdr l)) #\0)
                  "10"
                  (string (car l)))
                (if (not (char=? #\, (car l)))
                    (string (car l))
                    ""
                    )) (format (cdr l)))))
;за даден списък прескача елементите от тип ""
(define (skip-empty l)
  (if (null? l)
      '()
      (if (string=? "" (car l))
          (skip-empty (cdr l))
          (cons (car l) (skip-empty (cdr l))))))

;извършва сортиране ан списък с операция за сравнение на 2 елемента funcStr?
(define (insertion-sort l)
  (define (insert x l)
    (cond ((null? l) (list x))
          ((eq? #t (funcStr? x (car l)))
           (cons x l))
          (else
            (cons (car l) (insert x (cdr l))))))
  (foldr insert '() l))

;намира произведенеито на поизициите на 2та търсени елемента
(define (match l)
  (define (helper curr res ls)
   (if (null? ls)
       res
       (helper (+ 1 curr) (if (or (equal? (car ls) (list "[" "[" "2" "]" "]"))
                                  (equal? (car ls) (list "[" "[" "6" "]" "]")))
                              (* res (+ 1 curr))
                              res) (cdr ls))))
  (helper 0 1 l))

;към всеки ред от кода е показан пример и резултат от изпълнението
(define input (port->string in))
;-> "[[[[8,7,8,5,4],6,[4,6]]],[6,[[]]],[]]\r\n[[[[8,0,0,7,1],[1],8]]]"
(define splitIn (string-split char-whitespace? input))
;-> ("[[[[8,7,8,5,4],6,[4,6]]],[6,[[]]],[]]" "[[[[8,0,0,7,1],[1],8]]]")
(define splitInp (append splitIn (list "[[2]]" "[[6]]")))
;-> ("[[[[8,7,8,5,4],6,[4,6]]],[6,[[]]],[]]" "[[[[8,0,0,7,1],[1],8]]]" "[[2]]" "[[6]]")

(define formated (map (lambda(x) (skip-empty (format (string->list x)))) splitInp))
;-> (("[" "[" "[" "[" "8" "7" "8" "5" "4" "]" "6" "[" "4" "6" "]" "]" "]" "[" "6" "[" "[" "]" "]" "]" "[" "]" "]")
;   ("[" "[" "[" "[" "8" "0" "0" "7" "1" "]" "[" "1" "]" "8" "]" "]" "]")
;   ("[" "[" "2" "]" "]")
;  ("[" "[" "6" "]" "]"))

(match (insertion-sort formated))
;резултат