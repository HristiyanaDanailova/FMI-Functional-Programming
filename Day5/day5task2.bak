(#%require racket/port)
; отваря се порт , който чете от дадения файл
(define in (open-input-file "input.txt"))

; сравнява даден char с #\return
(define (char-return? ch)
  (char=? #\return ch))
; сравнява даден char с #\,
(define (char-comma? ch)
  (char=? #\, ch))
; сравнява даден char с #\-
(define (char-dash? ch)
  (char=? #\- ch))


; функция, която разделя стринг на лист от стрингове според подаден delimiter
;https://cookbook.scheme.org/split-string/
(define (string-split char-delimiter? string)
  (define (maybe-add a b parts)
    (if (= a b) parts (cons (substring string a b) parts)))
  (let ((n (string-length string)))
    (let loop ((a 0) (b 0) (parts '()))
      (if (< b n)
          (if (not (char-delimiter? (string-ref string b)))
              (loop a (+ b 1) parts)
              (loop (+ b 1) (+ b 1) (maybe-add a b parts)))
          (reverse (maybe-add a b parts))))))


(define (foldr op nv l)
  (if (null? l) nv
      (op (car l) (foldr op nv (cdr l)))))

(define (filter p l)
  (cond ((null? l) l)
        ((p (car l)) (cons (car l) (filter p (cdr l))))
        (else (filter p (cdr l)))))

;връща подсписък от индекс s до индекс e ключително
(define (sublist l s e)
  (define (helper ls curr res)
    (if (null? ls)
        res
        (helper (cdr ls) (+ curr 1) (if (and (>= curr s) (<= curr e))
                                        (append res (list (car ls)))
                                        res
                ))))
  (if (or ( < s 0) (< e s) (> s (length l)))
      '()
  (helper l 0 '())))
;функция, която разделя лист на подлистове според подаден delimiter
;https://codereview.stackexchange.com/questions/87058/splitting-a-list-in-racket
(define (split-by lst x)
  (foldr (lambda (element next)
           (if (eq? element x)
               (cons '() next)
               (cons (cons element (car next)) (cdr next))))
         (list '()) lst))
(define (make-lst l)
  (define (helper res ls)
    (if (null? ls)
        res
        (helper (append res (list (string (car ls)))) (cdr ls) )))
  (helper '() l))

;връща списъци само от числата или букви
(define (format l)
  (define (helper curr res)
    (if (> curr (length l))
        res
        (helper (+ curr 4) (append res (list (list-ref l curr))))))
  (helper 1 '()))
; от уоражнение на 2ра група
(define (any? p? lst)
  (foldr (lambda (x acc) (or (p? x) acc)) #f lst))
(define (zipWith f . lsts)
  (if (or (null? lsts)
          (any? null? lsts))
      '()
      (cons (apply f (map car lsts))
            (apply zipWith f (map cdr lsts)))))

;комбинира неограничен брой списъци поелементно
(define (combine l)
  (if (null? (filter (lambda(x) (not (null? x))) l))
     '()
     (append (list (zipWith car l)) (combine (map cdr l)))))

;разделя лист от стрингове според даден стринг 
(define (split-by-str lst x)
  (foldr (lambda (element next)
           (if (string=? element x)
               (cons '() next)
               (cons (cons element (car next)) (cdr next))))
         (list '()) lst))

;връща само елементите на нчетни позиции
(define (odd-ind l)
  (define (helper curr res)
    (if (= curr (length l))
        res
        (helper (+ curr 1) (if (odd? curr)
                               (append res (map (lambda(x) (apply string-append x)) (list (list-ref l curr))))
                               res))))
  (helper 0 '()))

;връща move на брой елемента от списък from 
(define (elem l m f t)
   (reverse (sublist (list-ref l (- f 1))  (- (length (list-ref l (- f 1)))  m) (- (length (list-ref l (- f 1))) 1))))
;добавя елементите върнати от elem към списъка to
(define (handle l m f t)
  (append (sublist l 0 (- t 2)) (list (append (list-ref l (- t 1)) (elem l m f t))) (sublist l t (- (length l)1 ))))
;премахва елементите от from,които са били преместени в списъка на to
(define (rm-els l m f)
  (append (sublist l 0 (- f 2)) (list (sublist (list-ref l (- f 1)) 0 ( - (length (list-ref l (- f 1)))(+ 1 m)))) (sublist l f (- (length l) 1))))

;извършва една команда над дадена конфигурация от елементи и връща резултата
(define (move cs l)
 (rm-els (handle l (car cs) (car (cdr cs)) (car (cdr (cdr cs))))  (car cs) (car (cdr cs))))

;извършва всички дадени команди на вскяа следваща конфигурация от елементи
(define (loop c l)
  (define (helper res cs)
    (if (null? cs)
        res
        (helper (move (car cs) res) (cdr cs))))
  (helper l c))


(define inp (port->string in))
;-> "    [D]    \r\n[N] [C]    \r\n[Z] [M] [P]\r\n 1   2   3 \r\n\r\nmove 1 from 2 to 1\r\nmove 3 from 1 to 3\r\nmove 2 from 2 to 1\r\nmove 1 from 1 to 2"
(define input (string->list inp))
;-> (#\space
;   #\space
;   #\space
;   #\space
;   #\[
;   #\D
;   #\]
;   #\space...)


(define splitted (map (lambda(y) (make-lst y))(map (lambda(x) (filter (lambda(y) (not (char=? #\return y))) x)) (split-by input #\newline))))
;->  ("[" "N" "]" " " "[" "C" "]" " " " " " " " ")
;    ("[" "Z" "]" " " "[" "M" "]" " " "[" "P" "]")
;    (" " "1" " " " " " " "2" " " " " " " "3" " ")
;    ()
;    ("m" "o" "v" "e" " " "1" " " "f" "r" "o" "m" " " "2" " " "t" "o" " " "1")
;    ("m" "o" "v" "e" " " "3" " " "f" "r" "o" "m" " " "1" " " "t" "o" " " "3")
;    ("m" "o" "v" "e" " " "2" " " "f" "r" "o" "m" " " "2" " " "t" "o" " " "1")
;    ("m" "o" "v" "e" " " "1" " " "f" "r" "o" "m" " " "1" " " "t" "o" " " "2"))

(define elems (split-by splitted '()))
;-> (((" " " " " " " " "[" "D" "]" " " " " " " " ")
;   ("[" "N" "]" " " "[" "C" "]" " " " " " " " ")
;   ("[" "Z" "]" " " "[" "M" "]" " " "[" "P" "]")
;   (" " "1" " " " " " " "2" " " " " " " "3" " "))
;   (("m" "o" "v" "e" " " "1" " " "f" "r" "o" "m" " " "2" " " "t" "o" " " "1")
;   ("m" "o" "v" "e" " " "3" " " "f" "r" "o" "m" " " "1" " " "t" "o" " " "3")
;   ("m" "o" "v" "e" " " "2" " " "f" "r" "o" "m" " " "2" " " "t" "o" " " "1")
;   ("m" "o" "v" "e" " " "1" " " "f" "r" "o" "m" " " "1" " " "t" "o" " " "2")))

(define combined (map (lambda(x) (reverse (filter (lambda(y) (not (string=? " " y))) x))) (combine (map format(car  elems)))))
;-> (("1" "Z" "N") ("2" "M" "C" "D") ("3" "P"))
(define commands (map (lambda(y)( map string->number y)) (map odd-ind (map (lambda(x)(split-by-str x " "))(car (cdr elems))))))
;-> ((1 2 1) (3 1 3) (2 2 1) (1 1 2))
(apply string-append (map (lambda(x) (car (reverse x)))(loop commands combined)))
;-> резултат


(close-input-port in)