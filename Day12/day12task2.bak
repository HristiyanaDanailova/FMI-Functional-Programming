(#%require racket/port)
; отваря се порт , който чете от дадения файл
(define in (open-input-file "input.txt"))

; функция, която разделя стринг на лист от стрингове според подаден delimiter
;https://cookbook.scheme.org/split-string/
(define (string-split char-delimiter? string)
  (define (maybe-add a b parts)
    (if (= a b) parts (cons (substring string a b) parts)))
  (let ((n (string-length string)))
    (let loop ((a 0) (b 0) (parts '()))
      (if (< b n)
          (if (not (char-delimiter? (string-ref string b)))
              (loop a (+ b 1) parts)
              (loop (+ b 1) (+ b 1) (maybe-add a b parts)))
          (reverse (maybe-add a b parts))))))

(define (filter p l)
  (cond ((null? l) l)
        ((p (car l)) (cons (car l) (filter p (cdr l))))
        (else (filter p (cdr l)))))


;асоциира char със съответната му стойност според ascii стойността му
(define (decode ch)
  (if (char-lower-case? ch)
      (- (char->integer ch) 96)
      (- (char->integer ch) 38)))

; ако елемента el е в списъка l връща индекса му, ако не , връща -1
(define (get-list-index l el)
    (if (null? l)
        -1
        (if (equal? (car l) el)
            0
            (let ((result (get-list-index (cdr l) el)))
                (if (= result -1)
                    -1
                    (+ 1 result))))))

;намира ch в матрицата m и връща двойка от вида (ред . колона) от съответните позиции
(define (findPos ch m)
  (define (helper res mr row)
    (if (null? mr)
        res
        (helper (if (not (null? (filter (lambda(x) (char=? x ch)) (car mr))))
                    (cons row (get-list-index (car mr) ch))
                    res
                    ) (cdr mr) (+ row 1))))
  (helper '() m 0))

; функции връщащи даден ред,колона или определен елемент
(define (get-row i m) (list-ref m i))
(define (get-col i m) (map (lambda(x)(list-ref x i)) m))
(define (get-el i j m)(get-row i (get-col j m)))

;проверява дали дадени индекси на елемент i и j са валидни и ако са връща двойка от вида (ред . колона), ако не са връща празен списък 
(define (inside i j m)
  (if (and (< -1 i)
           (< i (length m))
           (< -1 j)
           (< j (length (car m))))
          (cons i j)
          '()))

; връща съсведите на елемент с (i . j) позиции в m
; това са всички елементи, които се намират нагоре,надолу,вляво и вдясно от (i . j), такива, че индексите им са валидни, не са вече посещавани, и удовлетворяват изискването за допустима разлика във височината 
(define (neighbours i j m visited) 
  (filter (lambda(z) (< (- (get-el i j m) (get-el (car z) (cdr z) m)) 2))
  (filter (lambda(y) (= -1 (get-list-index visited y))) (filter (lambda(x) (not (null? x)))(list (inside (- i 1) j m)
        (inside (+ i 1) j m)
        (inside i (- j 1) m)
        (inside i (+ j 1) m)))
  )))

; за даден списък points от вида ( '(list pointsToVisist) '(list visited)) за всеки елемент на pointsToVisit намира neighbours и ги добавя към списъка с резултата
; при вече изчерпан списък от точки, които трябва да бъдат посетени се връща списък от вида ( '(res -> съдържа всички съседи на всички вече проверени точки) '(visited -> всички посетени точки, към които се прибавят и новите вече посетени точки))
(define (neighPoints m points)
  (define (helper res visited ls)
    (if (null? ls)
     (list (unique res) (unique (append visited res)))
           (helper (append res (unique (neighbours (car (car ls)) (cdr(car ls)) m visited)))
              visited
              (cdr ls)
              )))(helper '() (car (cdr points)) (car points)))

; проверява дали даден елемент е уникален за даден списък
(define (unique? l x)
  (if (> (length (filter (lambda(y) (equal? x y)) l)) 1)
      #f
      #t))
; оставя в списъка l само по 1 елемент от всеки вид
(define (unique lst)
  (define (helper lst result)
    (cond
      ((null? lst) result)
      ((member (car lst) result) (helper (cdr lst) result))
      (else (helper (cdr lst) (append result (list (car lst)))))))
  (helper lst '()))

; функцията приема координати на начална точка, списък от координати на крайни точки, както и матрица
; за дадената начална точка рекурсивно се намират съседите й, които са на 0+1 разстояние от нея
; за съседите на 0+1 разстояние се намират техните съседи, които да вече на разстояние 0+2 и тн.
; процесът продължава, докато елемент от списъка с индекси на крайните позиции не попадне в списъка visited
; тогава връщаме броят достигнати стъпки 
(define (pathIt i j m starts)
 (define (helper steps nextPoints)
   (if (not (null? (filter (lambda(x) (not (= -1 (get-list-index (car (cdr nextPoints)) x)))) starts)))
       steps
       (helper (+ steps 1) (neighPoints m nextPoints))))
 (helper  0 (list(list (cons i j) ) (list (cons i j) ))))


; намира индексите на да даден елемент за даден ред от матрица и ги връща като списък от двойки от вида (i . j)
(define (indexesOnRow i r el)
 (define (helper r col res)
   (if (null? r)
       res
       (helper (cdr r) (+ col 1) (if (= el (car r))
                                     (append res (list (cons i col)))
                                     res))))(helper r 0 '()))

; намира позициите на всички елементи в m със стойност 1
(define (starts m)
  (define (helper res mr i)
    (if (null? mr)
        res
        (helper (append res (indexesOnRow i (car mr) 1))
                (cdr mr)
                (+ i 1)
                )))
  (helper '() m 0))

(define input (port->string in))
;-> "Sabqponm\r\nabcryxxl\r\naccszExk\r\nacctuvwj\r\nabdefghi"
(define inputToStrs (string-split char-whitespace? input))
;-> ("Sabqponm" "abcryxxl" "accszExk" "acctuvwj" "abdefghi")
(define matrix (map string->list inputToStrs))
;-> ((#\S #\a #\b #\q #\p #\o #\n #\m) (#\a #\b #\c #\r #\y #\x #\x #\l) (#\a #\c #\c #\s #\z #\E #\x #\k) (#\a #\c #\c #\t #\u #\v #\w #\j) (#\a #\b #\d #\e #\f #\g #\h #\i))
(define mtr (map (lambda(y)(map (lambda(x) (if (char=? x #\S)
                                1
                                (if (char=? x #\E)
                                    26
                                    (decode x)))) y)) matrix))
;-> ((1 1 2 17 16 15 14 13) (1 2 3 18 25 24 24 12) (1 3 3 19 26 26 24 11) (1 3 3 20 21 22 23 10) (1 2 4 5 6 7 8 9))

(define endPos (findPos #\E matrix))
;-> (2 . 5)
(define starts (starts mtr))
;-> ((0 . 0) (0 . 1) (1 . 0) (2 . 0) (3 . 0) (4 . 0))
(define endPos (findPos #\E matrix))
(pathIt (car endPos) (cdr endPos) mtr starts)
;-> търси път от края до първото срещнато начало
; решението работи доста бавно,изчисляването на резултата може да отнеме до 2 минути, но работи коректно


(close-input-port in)