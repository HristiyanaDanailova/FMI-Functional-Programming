(#%require racket/port)
; отваря се порт , който чете от дадения файл
(define in (open-input-file "input2.txt"))

; функция, която разделя стринг на лист от стрингове според подаден delimiter
;https://cookbook.scheme.org/split-string/
(define (string-split char-delimiter? string)
  (define (maybe-add a b parts)
    (if (= a b) parts (cons (substring string a b) parts)))
  (let ((n (string-length string)))
    (let loop ((a 0) (b 0) (parts '()))
      (if (< b n)
          (if (not (char-delimiter? (string-ref string b)))
              (loop a (+ b 1) parts)
              (loop (+ b 1) (+ b 1) (maybe-add a b parts)))
          (reverse (maybe-add a b parts))))))


(define (foldr op nv l)
  (if (null? l) nv
      (op (car l) (foldr op nv (cdr l)))))

(define (filter p l)
  (cond ((null? l) l)
        ((p (car l)) (cons (car l) (filter p (cdr l))))
        (else (filter p (cdr l)))))

;проверява дали е достигнат искан брой цикли
(define (cycCheck cyc sum)
  (if (or (= cyc 20)
          (= cyc 60)
          (= cyc 100)
          (= cyc 140)
          (= cyc 180)
          (= cyc 220))
      #t
      #f))

; изпълнява всяка една от инструкциите, като при достигане на някой от определените циклли се записва двойка от вида (цикъл (сума * цикъл)) в res
(define (action l)
  (define (helper cycles sum res ls)
    (cond ((null? ls) res)
          ((string=? "noop" (car ls)) (helper (+ 1 cycles) sum (if (eq? (cycCheck cycles sum) #f)
                                                                   res
                                                                   (append res (list (cons cycles (* sum cycles))))) (cdr ls)))
          ((string=? "addx" (car ls)) (helper (+ cycles 2) (+ sum (string->number (car (cdr ls)))) (if (eq? (cycCheck cycles sum) #f)
                                                                                              (if (eq? (cycCheck (+ cycles 1) sum) #f)
                                                                                                  res
                                                                                                  (append  res (list (cons (+ 1 cycles) (* (+ 1 cycles) sum)))))
                                                                                                  (append  res (list (cons cycles (* cycles sum))))) (cdr (cdr ls))))
          
      ))
  (helper 1 1 '() l))

;към всеки ред от кода е показан пример и резултат от изпълнението
(define input (port->string in))
;-> "addx 15\r\naddx -11\r\naddx 6\r\naddx -3\r\naddx 5\r\naddx -1\r\naddx -8\r\naddx 13\r\naddx 4\r\nnoop\r\naddx -1"
(define splitInp (string-split char-whitespace? input))
;-> ("addx" "15" "addx" "-11" "addx" "6" "addx" "-3" "addx" "5" "addx" "-1" "addx" "-8" "addx" "13" "addx" "4" "noop" "addx" "-1")
(define cycles (action splitInp))
;-> ((20 . 420))
(foldr + 0 (map cdr cycles))


