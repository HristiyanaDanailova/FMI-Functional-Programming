(#%require racket/port)
; отваря се порт , който чете от дадения файл
(define in (open-input-file "input.txt"))

; сравнява даден char с #\,
(define (char-comma? ch)
  (char=? #\, ch))
; сравнява даден char с #\-
(define (char-dash? ch)
  (char=? #\- ch))


; функция, която разделя стринг на лист от стрингове според подаден delimiter
;https://cookbook.scheme.org/split-string/
(define (string-split char-delimiter? string)
  (define (maybe-add a b parts)
    (if (= a b) parts (cons (substring string a b) parts)))
  (let ((n (string-length string)))
    (let loop ((a 0) (b 0) (parts '()))
      (if (< b n)
          (if (not (char-delimiter? (string-ref string b)))
              (loop a (+ b 1) parts)
              (loop (+ b 1) (+ b 1) (maybe-add a b parts)))
          (reverse (maybe-add a b parts))))))


(define (foldr op nv l)
  (if (null? l) nv
      (op (car l) (foldr op nv (cdr l)))))

(define (filter p l)
  (cond ((null? l) l)
        ((p (car l)) (cons (car l) (filter p (cdr l))))
        (else (filter p (cdr l)))))

;създава двойки от елементите, разделени със ,
(define (make-pairs l)
  (if (null? l) l
      (append (list (cons (car (string-split char-comma? (car l)))
                          (car (cdr (string-split char-comma? (car l)))))) (make-pairs (cdr l)))
              ))
;генерира списък от числата от а до b
(define (interval a b)
  (if (> a b)
      '()
      (cons a (interval (+ a 1) b))))
;проверява дали даден елемент е част от списък
(define (memberR x l)
  (if (null? l)
      #f
      (if (eq? x (car l))
          #t
          (memberR x (cdr l)))))
;филтрира елементите, които са елементи на списъците, генерирани от дадените двойки едновременно и ако са 0, то двойките са валидни, а в противен случай са невалидни
(define (valPair? fPair sPair)
  (if (null? (filter (lambda(x) (memberR x (interval (car sPair) (cdr sPair)))
            )  (interval (car fPair) (cdr fPair))))
      #t
      #f))

;към всеки ред от кода е показан пример и резултат от изпълнението
(define inp (port->string in))
;-> "48-48,48-88\r\n59-92,80-95\r\n82-87,6-83\r\n81-97,13-81\r\n13-75,14-75\r\n97-98,21-97\r\n14-93,13-13\r\n21-32,20-31\r\n30-71,72-72"
(define inpToList (string-split char-whitespace? inp))
;-> ("48-48,48-88" "59-92,80-95" "82-87,6-83" "81-97,13-81" "13-75,14-75" "97-98,21-97" "14-93,13-13" "21-32,20-31" "30-71,72-72")
(define pairs (make-pairs inpToList))
;-> (("48-48" . "48-88")
;   ("59-92" . "80-95")
;   ("82-87" . "6-83")
;   ("81-97" . "13-81")
;   ("13-75" . "14-75")
;   ("97-98" . "21-97")
;   ("14-93" . "13-13")
;   ("21-32" . "20-31")
;   ("30-71" . "72-72"))
(define sepPairs
  (map (lambda(x) (list (cons (string->number (car (string-split char-dash? (car x)))) (string->number (car (cdr (string-split char-dash? (car x))))))
                        (cons (string->number (car (string-split char-dash? (cdr x)))) (string->number (car (cdr (string-split char-dash? (cdr x)))))))
  ) pairs))
;-> (((48 . 48) (48 . 88))
;   ((59 . 92) (80 . 95))
;   ((82 . 87) (6 . 83))
;   ((81 . 97) (13 . 81))
;   ((13 . 75) (14 . 75))
;   ((97 . 98) (21 . 97))
;   ((14 . 93) (13 . 13))
;   ((21 . 32) (20 . 31))
;   ((30 . 71) (72 . 72)))
(define invalPairs
  (filter (lambda(x) (eq? #f (valPair? (car x) (car (cdr x))))) sepPairs)
)
;-> (((48 . 48) (48 . 88)) ((59 . 92) (80 . 95)) ((82 . 87) (6 . 83)) ((81 . 97) (13 . 81)) ((13 . 75) (14 . 75)) ((97 . 98) (21 . 97)) ((21 . 32) (20 . 31)))
(length invalPairs)
(close-input-port in)